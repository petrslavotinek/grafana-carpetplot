{"version":3,"sources":["../src/data-converter.js"],"names":["moment","aggregate","getFragment","createConverter","aggregateType","fragmentType","createArray","length","initiator","Array","apply","map","prepareData","from","to","fragment","data","fromUtc","utc","startOf","toUtc","add","timeUtc","isBefore","nextTime","unix","time","values","groupData","dataList","container","forEach","datapoints","filter","value","timestamp","bucket","getBucket","push","aggregateData","min","Number","MAX_VALUE","max","MIN_VALUE","aggregateFunc","result","createBucket","buckets","count","local","Object","timeLocal","day","isSame","bucketIndex","getBucketIndex","stats","convertData"],"mappings":"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","file":"data-converter.js","sourcesContent":["import moment from 'moment';\n\nimport { aggregate } from './aggregates';\nimport { getFragment } from './fragments';\n\nconst createConverter = (aggregateType, fragmentType) => {\n\n  const createArray = (length, initiator = () => null) => Array.apply(null, { length }).map(initiator);\n\n  const prepareData = (from, to, fragment) => {\n    const data = {};\n    const fromUtc = moment.utc(from).startOf('day');\n    const toUtc = moment.utc(to).startOf('day').add(1, 'day');\n    for (let timeUtc = moment.utc(fromUtc); timeUtc.isBefore(toUtc); timeUtc = fragment.nextTime(timeUtc)) {\n      data[timeUtc.unix()] = {\n        time: timeUtc,\n        values: []\n      };\n    }\n    return {\n      data,\n      from: fromUtc,\n      to: toUtc\n    };\n  };\n\n  const groupData = (from, to, fragment, dataList) => {\n    const container = prepareData(from, to, fragment);\n    dataList.forEach(({ datapoints }) => {\n      datapoints\n        .filter(([value]) => value !== null)\n        .forEach(([value, timestamp]) => {\n          const bucket = fragment.getBucket(timestamp);\n          if (!(bucket in container.data)) { return; }\n          container.data[bucket].values.push(value);\n        });\n    });\n    return container;\n  };\n\n  const aggregateData = (from, to, fragment, data) => {\n    let min = Number.MAX_VALUE;\n    let max = Number.MIN_VALUE;\n\n    const aggregateFunc = aggregate(aggregateType);\n    const result = [];\n\n    const createBucket = (time) => ({\n      time,\n      buckets: createArray(fragment.count)\n    });\n\n    let bucket = createBucket(moment(from).local().startOf('day'));\n    Object.values(data).forEach(({ time, values }) => {\n      const timeLocal = time.local();\n      if (timeLocal.isBefore(bucket.time)) { return; }\n\n      const value = values.length > 0\n        ? aggregateFunc(values)\n        : null;\n      if (value !== null && value < min) { min = value; }\n      if (value !== null && value > max) { max = value; }\n\n      const day = moment(timeLocal).startOf('day');\n      if (!day.isSame(bucket.time)) {\n        result.push({ ...bucket });\n        bucket = createBucket(moment(day));\n      }\n\n      const bucketIndex = fragment.getBucketIndex(timeLocal);\n      bucket.buckets[bucketIndex] = value;\n    });\n\n    return {\n      data: result,\n      stats: {\n        min,\n        max\n      }\n    };\n  };\n\n  const convertData = (from, to, dataList) => {\n    const fragment = getFragment(fragmentType);\n    const container = groupData(from, to, fragment, dataList);\n    const data = aggregateData(from, to, fragment, container.data);\n    return {\n      ...container,\n      ...data\n    };\n  };\n\n  return {\n    convertData\n  };\n};\n\nexport default createConverter;"]}